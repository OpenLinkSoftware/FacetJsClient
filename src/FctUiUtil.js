// !!!! MOVE THIS TO FctReactClient !!!!
// FacetJsClient is supposed to be UI-agnositic with no UI parts
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

/**
 * FctUiUtil uses {{x}} placeholders to decouple FctQuery, specifically the Facet 
 * query description generated by FctQuery#queryDescription from the UI. The UI code,
 * not FctQuery, is responsible for replacing the placeholders.
 *
 * The placeholders comprise:
 *   - {{href}} :  A placeholder for an <a> element's href which must substituted by a URL to perform the desired UI action.
 *   - {{<cssClassName>}} : A placeholder for a CSS class (see FctUiUtil.css).
 *
 * data-xxx attributes indicate the action URL to be associated with an anchor element's href.
 * The action URL to replace a {{href}} marker is constructed from the value of the data-xxx attribute and, in the
 * case of data-fct-action, an accompanying context object.
 *
 * data-xxx attributes:
 *   - data-fct-action : <a> @href placeholder {{href}} should be set to perform the action indicated by context["action"].
 *   - data-class-uri : <a> @href placeholder {{href}} should be set to @data-class-uri value.
 *   - data-property-uri : <a> @href placeholder {{href}} should be set to @data-property-uri value.
 *
 * Recognized actions contained in context["action"]:
 *   - 'setFocus'
 *       args: subjectNodeIndex (used with data-fct-action)
 *   - 'setView' 
 *       args: viewType (text-properties|text|classes|properties|properties-in|list-count|list|full-text), offset, limit
 *   (TO DO: others to be added - see the corresponding facet.vsp cmd's below)
 *
 * The above actions are equivalent to those supported by facet.vsp, viz:
 *   - /fct/facet.vsp?cmd=text
 *   - /fct/facet.vsp?cmd=set_focus&n=%d (Corresponding FctUiUtil context action: setFocus)
 *   - /fct/facet.vsp?cmd=set_view&type=%s&limit=%d&offset=0 (Corresponding FctUiUtil context action: setView)
 *   - /fct/facet.vsp?cmd=refresh
 *   - /fct/facet.vsp?md=set_inf - Set inference context
 *   - /fct/facet.vsp?cmd=drop&n=%d
 *   - /fct/facet.vsp?cmd=drop_cond&cno=%d
 *   - /fct/facet.vsp?cmd=drop_text
 *   - /fct/facet.vsp?cmd=drop_text_prop
 */

export default class FctUiUtil {

  /**
   * 
   * @param {string} tripleTerminology - 'spo' or 'eav'.
   */
  constructor(triple_terminology = "spo")
  {
    this.tripleTerminology = triple_terminology;
  }

  get tripleTerminology() {
    return this._tripleTerminology;
  }

  set tripleTerminology(value) {
    if (!["spo", "eav"].includes(value.toLowerCase()))
      throw new Error('Unrecognized value');
    this._tripleTerminology = value.toLowerCase();
  }

  /**
   * Returns a parameterized HTML snippet wrapping a SPARQL query variable.
   * @param {int} this_s - subject node index (n) of current node. s1, s2, ... s(n).
   * @param {int} ctx - n of subject node s(n) to which the <view> element applies.
   */
  fctQryVariableAction(this_s, ctx)
  {
    // Equivalent to /fct PL routine fct_var_tag
    let focus = (this_s !== ctx) ? '' : '{{qryVarWithFocus}}';
    // /fct: href="/fct/facet.vsp?cmd=set_focus&sid=%d&n=%d" // TO DO: Remove
    let snippet = `
      <a class="${focus}" 
         href="{{href}}"
         data-fct-action
         title="Relation ${this.fctSubjectTerm()} ?s${this_s}">?s${this_s}</a>
      `;
    snippet = this.cleanHtmlSnippet(snippet);

    // context is used later by the UI to attach an action to an anchor tagged with data-fct-action
    let context = {
      action: "setFocus",
      actionArgs: {
        subjectNodeIndex: this_s
      }
    };

    return { snippet, context };
  }

  /**
   * Returns a parameterized HTML snippet wrapping an RDF property URI.
   * @param {string} propertyUri 
   */
  fctSetViewTextPropertiesAction(limit, cno)
  {
    // /fct: href="/fct/facet.vsp?sid=%d&cmd=set_view&type=text-properties&limit=%d&offset=0&cno=%d"
    let snippet = `
    <a class="{{qryInfoCmd}}"
       href="{{href}}" 
       data-fct-action>any ${this.fctPredicateTerm()}</a>
    `;
    snippet = this.cleanHtmlSnippet(snippet);

    // context is used later by the UI to attach an action to anchors tagged with data-fct-action
    let context = {
      action: "setView",
      actionArgs: {
        viewType: "text-properties",
        offset: 0,
        limit,
        cno
      }
    };

    return { snippet, context };
  }

  /**
   * Returns a parameterized HTML snippet wrapping an RDF property URI.
   * @param {string} propertyUri 
   */
  fctPropertyUriFrag(propertyUri)
  {
    let snippet = `
      <span class="{{propertyUri}}">
      <a href={{href}} data-property-uri="${propertyUri}">${this.fctShortForm(propertyUri)}</a>
      </span>
      `;
    return this.cleanHtmlSnippet(snippet);
  }

  /**
   * Returns a parameterized HTML snippet wrapping an RDF class URI.
   * @param {string} classUri 
   */
  fctClassUriFrag(classUri)
  {
    let snippet = `
      <span class="{{classUri}}">
      <a href="{{href}}" data-class-uri="${classUri}">${this.fctShortForm(classUri)}</a>
      </span>
      `;
    return this.cleanHtmlSnippet(snippet);
  }

  /**
   * Returns a parameterized HTML snippet wrapping an RDF text value.
   * @param {string} propertyUri 
   */
  fctTextValueFrag(text)
  {
    let snippet = `
    <span class="{{textValue}}">"${text}"</span>
    `;
    return this.cleanHtmlSnippet(snippet);
  }
  
  //
  // TO DO: Document
  //
  // The /fct terminology setting controls the terminology used to describe
  // the search filters being set through Facet XML.
  // The filter descriptions use either 'subject-predicate-object' or
  // 'entity-attribute-value' terminology.
  //
  //  terminology ::= 'spo' | 'eav'
  // 
  // The terminology setting determines the names used for each term in
  // a triple filter:
  //   'Subject' or 'Entity', 'Predicate' or 'Attribute', 'Object' or 'Value'
  // and in instance classification:
  //   'Class' or 'Type'
  //

  fctSubjectTerm() {
    // Equivalent to /fct PL routine fct_s_term
    return this._tripleTerminology === 'spo' ? 'subject' : 'entity';
  }

  fctClassTerm() {
    // Equivalent to /fct PL routine fct_t_term
    return this._tripleTerminology === 'spo' ? 'class' : 'type';
  }

  fctPredicateTerm() {
    // Equivalent to /fct PL routine fct_p_term
    return this._tripleTerminology === 'spo' ? 'predicate' : 'attribute';
  }

  fctObjectTerm() {
    // Equivalent to /fct PL routine fct_o_term
    return this._tripleTerminology === 'spo' ? 'object' : 'value';
  }

  /**
   * Returns a short string form of a URI or a SPARQL blank node identifier for display.
   * @param {*} val 
   */
  fctShortForm(val) {
    // Equivalent of /fct PL routine fct_short_form
    // TO DO: Implement
    // TO DO: Need a client-side equivalent of fct_uri_curie(), but
    // the latter uses Virtuoso function __xml_get_ns_prefix which
    // isn't available to the client.
    return `&lt;${val.toString().trim()}&gt;`;
  }

  cleanHtmlSnippet(html) {
    return html
      .replace(/\n/g, '')
      .replace(/\s+/g, ' ')
      .trim();
  }

}